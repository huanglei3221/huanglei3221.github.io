![image-20230609170611319](【技术学习】Flink学习笔记.assets/image-20230609170611319.png)





把原先的一来一回变成了有状态的

![image-20230609170706087](【技术学习】Flink学习笔记.assets/image-20230609170706087.png)

事件驱动型 和 数据分析性

![image-20230609170857989](【技术学习】Flink学习笔记.assets/image-20230609170857989.png)

1） flink和kafka链接是一种常见的架构



spark和 flink的区别： 

spark其实是化为了很多微批处理

而flink本身就是基于流的

![image-20230609171136473](【技术学习】Flink学习笔记.assets/image-20230609171136473.png)



flink看批数据：  有界数据流

flink看流数据：  无界数据流





对于Flink这种流处理来说， 一定要有个启动执行的动作， 前面只是动作的定义， Flink默认数据是连续不断地来的，不管有界无界。

![image-20230609171741208](【技术学习】Flink学习笔记.assets/image-20230609171741208.png)



## 部署

Flink中的主要组件：

![image-20230609172412341](【技术学习】Flink学习笔记.assets/image-20230609172412341.png)

### 三种抽象部署模式

![image-20230609172747962](【技术学习】Flink学习笔记.assets/image-20230609172747962.png)



#### 会话模式

![image-20230609172828639](【技术学习】Flink学习笔记.assets/image-20230609172828639.png)

![image-20230609172824022](【技术学习】Flink学习笔记.assets/image-20230609172824022.png)



#### 单作业模式

![image-20230609172946756](【技术学习】Flink学习笔记.assets/image-20230609172946756.png)

![image-20230609173011983](【技术学习】Flink学习笔记.assets/image-20230609173011983.png)

这种模式适合  创建作业后再分配资源





#### 应用模式（新增）

有点像单作业， 应用模式 是  应用和集群 1对1 

![image-20230609173146580](【技术学习】Flink学习笔记.assets/image-20230609173146580.png)



### 独立资源管理模式（standalone）

不支持单作业模式



### YARN资源管理模式

![image-20230609173537987](【技术学习】Flink学习笔记.assets/image-20230609173537987.png)

## 系统架构

![image-20230609174550110](【技术学习】Flink学习笔记.assets/image-20230609174550110.png)

### Jobmanager

![image-20230609174725364](【技术学习】Flink学习笔记.assets/image-20230609174725364.png)

![image-20230609174837093](【技术学习】Flink学习笔记.assets/image-20230609174837093.png)

### TaskManager

![image-20230609174943234](【技术学习】Flink学习笔记.assets/image-20230609174943234.png)

### 提交作业流程：

![image-20230609175151035](【技术学习】Flink学习笔记.assets/image-20230609175151035.png)

#### StandAlone下提交作业

![image-20230609175323838](【技术学习】Flink学习笔记.assets/image-20230609175323838.png)

#### YARN下提交作业

![image-20230609175411047](【技术学习】Flink学习笔记.assets/image-20230609175411047.png)

### 程序和数据流

![image-20230609180431597](【技术学习】Flink学习笔记.assets/image-20230609180431597.png)

Transform ： 利用算子进行计算



### 并行度

![image-20230609180755915](【技术学习】Flink学习笔记.assets/image-20230609180755915.png)

并行度是针对算子说的， 可以配置



![image-20230609181142118](【技术学习】Flink学习笔记.assets/image-20230609181142118.png)

#### 算子链的合并

![image-20230609181247582](【技术学习】Flink学习笔记.assets/image-20230609181247582.png)



![image-20230609181337290](【技术学习】Flink学习笔记.assets/image-20230609181337290.png)



### 执行图

![image-20230609182126612](【技术学习】Flink学习笔记.assets/image-20230609182126612.png)



![image-20230609182149582](【技术学习】Flink学习笔记.assets/image-20230609182149582.png)



### 任务task和任务槽slot的关系

![image-20230609182320818](【技术学习】Flink学习笔记.assets/image-20230609182320818.png)





![image-20230609182506010](【技术学习】Flink学习笔记.assets/image-20230609182506010.png)

slot可以共用

同一个算子的并行子任务放在不同的slot， 并行度最大的那个算子就是需要的slot数量。



![image-20230609182831384](【技术学习】Flink学习笔记.assets/image-20230609182831384.png)









